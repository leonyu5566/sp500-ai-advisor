<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ¨™æ™®500 AI ç­–ç•¥é¡§å•ç³»çµ±</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.autotable.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* çœç•¥ï¼šåŸå…ˆçš„ CSS å…¨æ•¸ä¿ç•™ */
    </style>
</head>
<body class="bg-gray-100">
    <!-- çœç•¥ï¼šåŸå…ˆ HTML çµæ§‹å®Œå…¨ä¿ç•™ -->

<script>
/****************************************************
 * âœ¨ æ–°å¢ï¼šé›²ç«¯æ¨è«– API ç«¯é»
 ****************************************************/
const PREDICT_API_URL = "https://my-vertex-proxy-1095766716155.asia-east1.run.app/predict";

/****************************************************
 * åŸæœ‰å…¨åŸŸè®Šæ•¸ & å‡½å¼ (ä¿ç•™)
 ****************************************************/
let historicalData = /* åŸæœ¬çš„æ­·å²è³‡æ–™é™£åˆ— */ [];
let latestForecastResults = [];
let latestInitialInputs = {};
/* â€¦åŸæœ¬å…¶å®ƒå…¨åŸŸå¸¸æ•¸èˆ‡å‡½å¼â€¦ */

/****************************************************
 * ğŸ”„ fetchPredict() â€“ å‘¼å« Vertex AI Proxy å–å¾—å–®æœŸé æ¸¬
 * @param {Object} featureDict â€“ ç¬¦åˆæ¨¡å‹ç‰¹å¾µåç¨±çš„æ•¸å€¼ç‰©ä»¶
 * @returns {Number} â€“ é æ¸¬çš„ä¸‹ä¸€æœŸ S&PÂ 500 æŒ‡æ•¸
 ****************************************************/
async function fetchPredict(featureDict) {
    try {
        const resp = await fetch(PREDICT_API_URL, {
            method: 'POST',
            mode: 'cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ instances: [featureDict] })
        });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const json = await resp.json();
        if (!json.predictions || !Array.isArray(json.predictions)) throw new Error('Invalid response');
        return parseFloat(json.predictions[0]);
    } catch (err) {
        console.error('Predict API error:', err);
        throw err;
    }
}

/****************************************************
 * ğŸš€ è¦†å¯« initMonthlyForecast() ä¸­çš„é æ¸¬æµç¨‹
 *     æ”¹ç‚ºé€æœˆå‘¼å« Cloud Run API è€Œéå‰ç«¯å‡å…¬å¼
 ****************************************************/
function initMonthlyForecast() {
    const form = document.getElementById('predictionForm');
    const runFutureForecastBtn = document.getElementById('runFutureForecast');

    /* 1. å‹•æ…‹ç”¢ç”Ÿè¼¸å…¥è¡¨å–® (ä¿æŒåŸæµç¨‹) */
    const defaultFormValues = historicalData.at(-1);
    form.innerHTML = '';
    Object.keys(modelFeatureNames).forEach(key => {
        form.insertAdjacentHTML('beforeend',
            `<div><label for="input-${key}" class="block text-xs font-medium text-gray-600">${modelFeatureNames[key]}</label><input type="number" id="input-${key}" name="${key}" step="any" class="form-input mt-1 block w-full px-2 py-1.5 text-sm" value="${defaultFormValues[key] || ''}"></div>`);
    });

    /* 2. ç›£è½æŒ‰éˆ• */
    runFutureForecastBtn.addEventListener('click', async () => {
        const initialInputs = {};
        const formData = new FormData(form);
        for (const [k, v] of formData.entries()) {
            if (v === '' || isNaN(v)) { showNotification('è«‹å¡«å¯«æ‰€æœ‰æœ‰æ•ˆçš„åˆå§‹æ•¸å€¼ã€‚', 'error'); return; }
            initialInputs[k] = parseFloat(v);
        }
        const monthsToForecast = +document.getElementById('monthsToForecast').value;
        latestForecastResults = [];
        latestInitialInputs = { ...initialInputs };

        /* 3. é€æœˆå‘¼å« API ç«¯é» */
        let current = { ...initialInputs };
        showNotification('æ­£åœ¨å‘ AI æ¨¡å‹è«‹æ±‚é æ¸¬ï¼Œè«‹ç¨å€™â€¦', 'info');
        for (let i = 0; i < monthsToForecast; i++) {
            try {
                const pred = await fetchPredict(current);
                latestForecastResults.push(pred);
                /* Shift timeâ€‘series featuresçµ¦ä¸‹ä¸€æ¬¡ */
                current.t_2 = current.t_1;
                current.t_1 = pred;
            } catch (err) {
                showNotification(`ç¬¬ ${i + 1} æœŸé æ¸¬å¤±æ•—ï¼š${err.message}`, 'error');
                return;
            }
        }
        renderForecastChart();
        showNotification('æ¨¡å‹é æ¸¬å®Œæˆï¼', 'success');
    });
}

/****************************************************
 * ğŸ–¼ï¸ ä¾æœ€æ–°é æ¸¬çµæœï¼Œæ›´æ–°åœ–è¡¨èˆ‡è¡¨æ ¼ â€“ æŠ½å‡ºæˆå‡½å¼
 ****************************************************/
function renderForecastChart() {
    const futureSection = document.getElementById('futureForecastSection');
    const placeholder = document.getElementById('forecast-placeholder');
    const tableBody = document.getElementById('futurePredictionTableBody');
    const lastHistoryDate = new Date(historicalData.at(-1).date + '-01');

    /* labels & table */
    const labels = [], dataPoints = [latestInitialInputs.t_1];
    tableBody.innerHTML = '';
    latestForecastResults.forEach((val, idx) => {
        const d = new Date(lastHistoryDate);
        d.setMonth(d.getMonth() + idx + 1);
        labels.push(d);
        dataPoints.push(val);
        tableBody.insertAdjacentHTML('beforeend',
            `<tr><td class="px-4 py-3 text-sm">${d.toLocaleDateString('zh-TW', { year: 'numeric', month: '2-digit' })}</td><td class="px-4 py-3 text-sm">${val.toLocaleString('en-US')}</td></tr>`);
    });

    /* chart */
    const ctx = document.getElementById('futurePredictionChart').getContext('2d');
    chartInstances.futureChart = createChart(ctx, chartInstances.futureChart, 'line', {
        labels,
        datasets: [{ label: 'S&P 500 é æ¸¬èµ°å‹¢', data: dataPoints, borderColor: '#16a34a', backgroundColor: 'rgba(22,163,74,0.1)', tension: 0.3, fill: true }]
    }, { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'month' } } } });

    placeholder.classList.add('hidden');
    futureSection.classList.remove('hidden');
}

/*****************************************************************
 * å…¶é¤˜åŸå…ˆçš„ç¨‹å¼ç¢¼ (initDashboard / initQARobot / etc.) ä¿æŒä¸è®Š
 *****************************************************************/
</script>
</body>
</html>
