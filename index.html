<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>標普500 AI 策略顧問系統</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <!-- jsPDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.23/jspdf.autotable.min.js"></script>
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        /* 省略：原先的 CSS 全數保留 */
    </style>
</head>
<body class="bg-gray-100">
    <!-- 省略：原先 HTML 結構完全保留 -->

<script>
/****************************************************
 * ✨ 新增：雲端推論 API 端點
 ****************************************************/
const PREDICT_API_URL = "https://my-vertex-proxy-1095766716155.asia-east1.run.app/predict";

/****************************************************
 * 原有全域變數 & 函式 (保留)
 ****************************************************/
let historicalData = /* 原本的歷史資料陣列 */ [];
let latestForecastResults = [];
let latestInitialInputs = {};
/* …原本其它全域常數與函式… */

/****************************************************
 * 🔄 fetchPredict() – 呼叫 Vertex AI Proxy 取得單期預測
 * @param {Object} featureDict – 符合模型特徵名稱的數值物件
 * @returns {Number} – 預測的下一期 S&P 500 指數
 ****************************************************/
async function fetchPredict(featureDict) {
    try {
        const resp = await fetch(PREDICT_API_URL, {
            method: 'POST',
            mode: 'cors',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ instances: [featureDict] })
        });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const json = await resp.json();
        if (!json.predictions || !Array.isArray(json.predictions)) throw new Error('Invalid response');
        return parseFloat(json.predictions[0]);
    } catch (err) {
        console.error('Predict API error:', err);
        throw err;
    }
}

/****************************************************
 * 🚀 覆寫 initMonthlyForecast() 中的預測流程
 *     改為逐月呼叫 Cloud Run API 而非前端假公式
 ****************************************************/
function initMonthlyForecast() {
    const form = document.getElementById('predictionForm');
    const runFutureForecastBtn = document.getElementById('runFutureForecast');

    /* 1. 動態產生輸入表單 (保持原流程) */
    const defaultFormValues = historicalData.at(-1);
    form.innerHTML = '';
    Object.keys(modelFeatureNames).forEach(key => {
        form.insertAdjacentHTML('beforeend',
            `<div><label for="input-${key}" class="block text-xs font-medium text-gray-600">${modelFeatureNames[key]}</label><input type="number" id="input-${key}" name="${key}" step="any" class="form-input mt-1 block w-full px-2 py-1.5 text-sm" value="${defaultFormValues[key] || ''}"></div>`);
    });

    /* 2. 監聽按鈕 */
    runFutureForecastBtn.addEventListener('click', async () => {
        const initialInputs = {};
        const formData = new FormData(form);
        for (const [k, v] of formData.entries()) {
            if (v === '' || isNaN(v)) { showNotification('請填寫所有有效的初始數值。', 'error'); return; }
            initialInputs[k] = parseFloat(v);
        }
        const monthsToForecast = +document.getElementById('monthsToForecast').value;
        latestForecastResults = [];
        latestInitialInputs = { ...initialInputs };

        /* 3. 逐月呼叫 API 端點 */
        let current = { ...initialInputs };
        showNotification('正在向 AI 模型請求預測，請稍候…', 'info');
        for (let i = 0; i < monthsToForecast; i++) {
            try {
                const pred = await fetchPredict(current);
                latestForecastResults.push(pred);
                /* Shift time‑series features給下一次 */
                current.t_2 = current.t_1;
                current.t_1 = pred;
            } catch (err) {
                showNotification(`第 ${i + 1} 期預測失敗：${err.message}`, 'error');
                return;
            }
        }
        renderForecastChart();
        showNotification('模型預測完成！', 'success');
    });
}

/****************************************************
 * 🖼️ 依最新預測結果，更新圖表與表格 – 抽出成函式
 ****************************************************/
function renderForecastChart() {
    const futureSection = document.getElementById('futureForecastSection');
    const placeholder = document.getElementById('forecast-placeholder');
    const tableBody = document.getElementById('futurePredictionTableBody');
    const lastHistoryDate = new Date(historicalData.at(-1).date + '-01');

    /* labels & table */
    const labels = [], dataPoints = [latestInitialInputs.t_1];
    tableBody.innerHTML = '';
    latestForecastResults.forEach((val, idx) => {
        const d = new Date(lastHistoryDate);
        d.setMonth(d.getMonth() + idx + 1);
        labels.push(d);
        dataPoints.push(val);
        tableBody.insertAdjacentHTML('beforeend',
            `<tr><td class="px-4 py-3 text-sm">${d.toLocaleDateString('zh-TW', { year: 'numeric', month: '2-digit' })}</td><td class="px-4 py-3 text-sm">${val.toLocaleString('en-US')}</td></tr>`);
    });

    /* chart */
    const ctx = document.getElementById('futurePredictionChart').getContext('2d');
    chartInstances.futureChart = createChart(ctx, chartInstances.futureChart, 'line', {
        labels,
        datasets: [{ label: 'S&P 500 預測走勢', data: dataPoints, borderColor: '#16a34a', backgroundColor: 'rgba(22,163,74,0.1)', tension: 0.3, fill: true }]
    }, { responsive: true, maintainAspectRatio: false, scales: { x: { type: 'time', time: { unit: 'month' } } } });

    placeholder.classList.add('hidden');
    futureSection.classList.remove('hidden');
}

/*****************************************************************
 * 其餘原先的程式碼 (initDashboard / initQARobot / etc.) 保持不變
 *****************************************************************/
</script>
</body>
</html>
